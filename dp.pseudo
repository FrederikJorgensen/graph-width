case "introduce node":
  foreach ps in partialSolutions

    case v is 0:
      v → 0
      Old matching → new matching
     
    case v is 1:
      for each w in child bag
        check if there exists an wv edge in G
          if true:
            case w is 0:
              We make w → 1
              We make v → 1 
              Add the pair (w,v) to the matching
            case w is 1:
              Find pair that contains (u,w) make it (u,v)
              Make v → 1
              Make w → 2

    case v is 2:
      for each w in child bag
        check if there exists
        find 2 edges that are in different pairs
        Find 2 Endpoints, endpoints can have degree 0 and degree 1

case "forget node":

case "join node":  
  rightTableKeys = getRightTableKeys()
  leftTableKeys = getLeftTableKeys()

  if START_NODE in d
    if degree of START_NODE === 0 OR START_NODE === 1

  if END_NODE in d
    if degree of END_NODE === 0 OR START_NODE === 1

  for(i = 0; i < leftTableKeys.length; i++)
    leftState = leftTableKeys[i]
    rightState = rightTableKeys[i]

    leftD = leftState[0]
    rightD = rightState[0]

    currentTable = getSum(leftD, rightD)
    values = currentTable.values()

    for each value in values
      if value <= 2

   leftMatching = leftState[1]
   rightMatching = rightState[1]

   newMatching = leftMacthing.concat(rightMatching)

   subGraph = createSubgraph(newMatching)

   containsCycles(subGraph)
    
S can have degree 0 throughout the DP but once you forget S it must have degree 1. It must also be a pair in some matching.

Function that finds path until vertex degree 1.

M’’ iterate over each pair in the matching and check the paths.

Degree must be 2
Or 1 if we are at the endpoint of a path

Check v, w as start and end point, must be degree 1.



d       M
a → 1   [ [a,b] ]
b → 1

We want to introduce the vertex c with degree 2.

a → 2   []
b → 2
c -> 2







